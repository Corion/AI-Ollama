package AI::Ollama::Client::Impl 0.01;
# DO NOT EDIT! This is an autogenerated file.
use 5.020;
use Moo 2;
use experimental 'signatures';

# These should go into a ::Role
use YAML::PP;
use Mojo::UserAgent;
use OpenAPI::Modern;

use Future::Mojo;

use AI::Ollama::CopyModelRequest;
use AI::Ollama::CreateModelRequest;
use AI::Ollama::CreateModelResponse;
use AI::Ollama::DeleteModelRequest;
use AI::Ollama::GenerateChatCompletionRequest;
use AI::Ollama::GenerateChatCompletionResponse;
use AI::Ollama::GenerateCompletionRequest;
use AI::Ollama::GenerateCompletionResponse;
use AI::Ollama::GenerateEmbeddingRequest;
use AI::Ollama::GenerateEmbeddingResponse;
use AI::Ollama::Message;
use AI::Ollama::Model;
use AI::Ollama::ModelInfo;
use AI::Ollama::ModelInfoRequest;
use AI::Ollama::ModelsResponse;
use AI::Ollama::PullModelRequest;
use AI::Ollama::PullModelResponse;
use AI::Ollama::PushModelRequest;
use AI::Ollama::PushModelResponse;
use AI::Ollama::RequestOptions;

# XXX this should be more configurable, and potentially you don't want validation?!
my $schema = YAML::PP->new( boolean => 'JSON::PP' )->load_file( 'ollama/ollama-curated.yaml' );
has 'openapi' => (
    is => 'lazy',
    default => sub { OpenAPI::Modern->new( openapi_schema => $schema, openapi_uri => '/api' )},
);

# The HTTP stuff should go into a ::Role I guess
has 'ua' => (
    is => 'lazy',
    default => sub { Mojo::UserAgent->new },
);

has 'server' => (
    is => 'lazy',
    default => sub { 'http://localhost:11434/api' }, # XXX pull from OpenAPI file instead
);

=head2 C<< checkBlob >>

  my $res = $client->checkBlob()->get;

Check to see if a blob exists on the Ollama server which is useful when creating models.


=cut

sub checkBlob( $self, %options ) {

    my $method = 'HEAD';
    my $url = $self->server . '/blobs/{digest}';

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            "Content-Type" => '',
        }
        # XXX Need to fill the body
        # => $body,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    say $results;
    say $tx->req->to_string;

    # We need to start $tx here and then append us to the promise?!
    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;

        if( $resp->code == 200 ) {
            # Blob exists on the server
            return Future::Mojo->done($resp);
        }
        if( $resp->code == 404 ) {
            # Blob was not found
            return Future::Mojo->done($resp);
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createBlob >>

  my $res = $client->createBlob()->get;

Create a blob from a file. Returns the server file path.


=cut

sub createBlob( $self, %options ) {

    my $method = 'POST';
    my $url = $self->server . '/blobs/{digest}';

    my $request = AI::Ollama::->new( \%options );
    # resp. validate %options against 
    # send as application/octet-stream
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            "Content-Type" => 'application/octet-stream',
        }
        # XXX Need to fill the body
        # => $body,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    say $results;
    say $tx->req->to_string;

    # We need to start $tx here and then append us to the promise?!
    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;

        if( $resp->code == 201 ) {
            # Blob was successfully created
            return Future::Mojo->done($resp);
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< generateChatCompletion >>

  my $res = $client->generateChatCompletion()->get;

Generate the next message in a chat with a provided model.

Returns a L<< AI::Ollama::GenerateChatCompletionResponse >>.

=cut

sub generateChatCompletion( $self, %options ) {

    my $method = 'POST';
    my $url = $self->server . '/chat';

    my $request = AI::Ollama::GenerateChatCompletionRequest->new( \%options );
    # resp. validate %options against GenerateChatCompletionRequest
    # send as application/json
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    say $results;
    say $tx->req->to_string;

    # We need to start $tx here and then append us to the promise?!
    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;

        if( $resp->code == 200 ) {
            # Successful operation.
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/x-ndjson' ) {
                my $payload = $resp->body(); # application/x-ndjson
                return Future::Mojo->done(
                    AI::Ollama::GenerateChatCompletionResponse->new($payload),
                );
            }
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< copyModel >>

  my $res = $client->copyModel()->get;

Creates a model with another name from an existing model.


=cut

sub copyModel( $self, %options ) {

    my $method = 'POST';
    my $url = $self->server . '/copy';

    my $request = AI::Ollama::CopyModelRequest->new( \%options );
    # resp. validate %options against CopyModelRequest
    # send as application/json
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    say $results;
    say $tx->req->to_string;

    # We need to start $tx here and then append us to the promise?!
    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;

        if( $resp->code == 200 ) {
            # Successful operation.
            return Future::Mojo->done($resp);
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createModel >>

  my $res = $client->createModel()->get;

Create a model from a Modelfile.

Returns a L<< AI::Ollama::CreateModelResponse >>.

=cut

sub createModel( $self, %options ) {

    my $method = 'POST';
    my $url = $self->server . '/create';

    my $request = AI::Ollama::CreateModelRequest->new( \%options );
    # resp. validate %options against CreateModelRequest
    # send as application/json
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    say $results;
    say $tx->req->to_string;

    # We need to start $tx here and then append us to the promise?!
    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;

        if( $resp->code == 200 ) {
            # Successful operation.
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/x-ndjson' ) {
                my $payload = $resp->body(); # application/x-ndjson
                return Future::Mojo->done(
                    AI::Ollama::CreateModelResponse->new($payload),
                );
            }
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< deleteModel >>

  my $res = $client->deleteModel()->get;

Delete a model and its data.


=cut

sub deleteModel( $self, %options ) {

    my $method = 'DELETE';
    my $url = $self->server . '/delete';

    my $request = AI::Ollama::DeleteModelRequest->new( \%options );
    # resp. validate %options against DeleteModelRequest
    # send as application/json
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    say $results;
    say $tx->req->to_string;

    # We need to start $tx here and then append us to the promise?!
    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;

        if( $resp->code == 200 ) {
            # Successful operation.
            return Future::Mojo->done($resp);
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< generateEmbedding >>

  my $res = $client->generateEmbedding()->get;

Generate embeddings from a model.

Returns a L<< AI::Ollama::GenerateEmbeddingResponse >>.

=cut

sub generateEmbedding( $self, %options ) {

    my $method = 'POST';
    my $url = $self->server . '/embeddings';

    my $request = AI::Ollama::GenerateEmbeddingRequest->new( \%options );
    # resp. validate %options against GenerateEmbeddingRequest
    # send as application/json
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    say $results;
    say $tx->req->to_string;

    # We need to start $tx here and then append us to the promise?!
    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;

        if( $resp->code == 200 ) {
            # Successful operation.
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    AI::Ollama::GenerateEmbeddingResponse->new($payload),
                );
            }
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< generateCompletion >>

  my $res = $client->generateCompletion()->get;

Generate a response for a given prompt with a provided model.

Returns a L<< AI::Ollama::GenerateCompletionResponse >>.

=cut

sub generateCompletion( $self, %options ) {

    my $method = 'POST';
    my $url = $self->server . '/generate';

    my $request = AI::Ollama::GenerateCompletionRequest->new( \%options );
    # resp. validate %options against GenerateCompletionRequest
    # send as application/json
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    say $results;
    say $tx->req->to_string;

    # We need to start $tx here and then append us to the promise?!
    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;

        if( $resp->code == 200 ) {
            # Successful operation.
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/x-ndjson' ) {
                my $payload = $resp->body(); # application/x-ndjson
                return Future::Mojo->done(
                    AI::Ollama::GenerateCompletionResponse->new($payload),
                );
            }
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< pullModel >>

  my $res = $client->pullModel()->get;

Download a model from the ollama library.

Returns a L<< AI::Ollama::PullModelResponse >>.

=cut

sub pullModel( $self, %options ) {

    my $method = 'POST';
    my $url = $self->server . '/pull';

    my $request = AI::Ollama::PullModelRequest->new( \%options );
    # resp. validate %options against PullModelRequest
    # send as application/json
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    say $results;
    say $tx->req->to_string;

    # We need to start $tx here and then append us to the promise?!
    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;

        if( $resp->code == 200 ) {
            # Successful operation.
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    AI::Ollama::PullModelResponse->new($payload),
                );
            }
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< pushModel >>

  my $res = $client->pushModel()->get;

Upload a model to a model library.

Returns a L<< AI::Ollama::PushModelResponse >>.

=cut

sub pushModel( $self, %options ) {

    my $method = 'POST';
    my $url = $self->server . '/push';

    my $request = AI::Ollama::PushModelRequest->new( \%options );
    # resp. validate %options against PushModelRequest
    # send as application/json
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    say $results;
    say $tx->req->to_string;

    # We need to start $tx here and then append us to the promise?!
    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;

        if( $resp->code == 200 ) {
            # Successful operation.
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    AI::Ollama::PushModelResponse->new($payload),
                );
            }
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< showModelInfo >>

  my $res = $client->showModelInfo()->get;

Show details about a model including modelfile, template, parameters, license, and system prompt.

Returns a L<< AI::Ollama::ModelInfo >>.

=cut

sub showModelInfo( $self, %options ) {

    my $method = 'POST';
    my $url = $self->server . '/show';

    my $request = AI::Ollama::ModelInfoRequest->new( \%options );
    # resp. validate %options against ModelInfoRequest
    # send as application/json
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    say $results;
    say $tx->req->to_string;

    # We need to start $tx here and then append us to the promise?!
    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;

        if( $resp->code == 200 ) {
            # Successful operation.
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    AI::Ollama::ModelInfo->new($payload),
                );
            }
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< listModels >>

  my $res = $client->listModels()->get;

List models that are available locally.

Returns a L<< AI::Ollama::ModelsResponse >>.

=cut

sub listModels( $self, %options ) {

    my $method = 'GET';
    my $url = $self->server . '/tags';

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            "Content-Type" => '',
        }
        # XXX Need to fill the body
        # => $body,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    say $results;
    say $tx->req->to_string;

    # We need to start $tx here and then append us to the promise?!
    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;

        if( $resp->code == 200 ) {
            # Successful operation.
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    AI::Ollama::ModelsResponse->new($payload),
                );
            }
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}


1;
